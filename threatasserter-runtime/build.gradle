import org.aspectj.bridge.IMessage
import org.aspectj.bridge.MessageHandler
import org.aspectj.tools.ajc.Main

apply plugin: 'com.android.library'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'maven-publish'

dependencies {
  compile 'org.aspectj:aspectjrt:1.8.6'
  compile project(':threatasserter-annotations')

  testCompile 'junit:junit:4.12'
}

android {
  compileSdkVersion rootProject.ext.compileSdkVersion
  buildToolsVersion rootProject.ext.buildToolsVersion

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_7
    targetCompatibility JavaVersion.VERSION_1_7
  }
}

android.libraryVariants.all { variant ->
  JavaCompile javaCompile = variant.javaCompile
  javaCompile.doLast {
    String[] args = [
        "-showWeaveInfo",
        "-1.5",
        "-inpath", javaCompile.destinationDir.toString(),
        "-aspectpath", javaCompile.classpath.asPath,
        "-d", javaCompile.destinationDir.toString(),
        "-classpath", javaCompile.classpath.asPath,
        "-bootclasspath", android.bootClasspath.join(File.pathSeparator)
    ]

    MessageHandler handler = new MessageHandler(true);
    new Main().run(args, handler)

    def log = project.logger
    for (IMessage message : handler.getMessages(null, true)) {
      switch (message.getKind()) {
        case IMessage.ABORT:
        case IMessage.ERROR:
        case IMessage.FAIL:
          log.error message.message, message.thrown
          break
        case IMessage.WARNING:
        case IMessage.INFO:
          log.info message.message, message.thrown
          break
        case IMessage.DEBUG:
          log.debug message.message, message.thrown
          break
      }
    }
  }
}


def projectGroupId = GROUP
def versionName = VERSION_NAME
def projectName = "threatasserter-runtime"

publishing {
  publications {
    Production(MavenPublication) {
      artifact("$buildDir/outputs/aar/threatasserter-runtime-release.aar")
      groupId projectGroupId
      artifactId projectName
      version versionName

      //The publication doesn't know about our dependencies, so we have to manually add them to the pom
      pom.withXml {
        def dependenciesNode = asNode().appendNode('dependencies')

        //Iterate over the compile dependencies (we don't want the test ones), adding a <dependency> node for each
        configurations.compile.allDependencies.each {
          def dependencyNode = dependenciesNode.appendNode('dependency')
          dependencyNode.appendNode('groupId', it.group)
          dependencyNode.appendNode('artifactId', it.name)
          dependencyNode.appendNode('version', it.version)
        }
      }
    }
  }
}

bintray {
  user = project.hasProperty('bintrayUser') ? project.property('bintrayUser') :
          System.getenv('BINTRAY_USER')
  key = project.hasProperty('bintrayApiKey') ? project.property('bintrayApiKey') :
          System.getenv('BINTRAY_API_KEY')

  pkg {
    repo = POM_LICENCE_DIST
    name = projectName
    licenses = [POM_LICENCE_NAME]
    vcsUrl = POM_SCM_CONNECTION
    version {
      name = versionName
      desc = POM_DESCRIPTION
      vcsTag = versionName
      attributes = ['gradle-plugin': 'com.use.less:com.use.less.gradle:gradle-useless-plugin']
    }
  }
  publications = ['Production']
}
